# -*-eselect-*-  vim: ft=eselect
# Copyright 2009-2011 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2 or later
# $Id: $

DESCRIPTION="Manage default settings for systemwide GNOME Shell extensions"
AUTHOR="tetromino@gmail.com"
MAINTAINER="gnome@gentoo.org"
SVN_DATE='$Date: 2011/09/11 18:00:00 -0400 $'
VERSION=$(svn_date_to_version "${SVN_DATE}")

#
# Basic idea: eselect manages a gschema override file located in
# /etc/eselect/gnome-shell-extensions/ that overrides GNOME Shell's
# 'disabled-extensions' or 'enabled-extensions' (depending on
# current shell version) GSettings key; the override file is
# symlinked from /usr/share/glib-2.0/schemas/
#

gse_prepare() {
	XDG_DATA_DIRS=${XDG_DATA_DIRS:="${EROOT}/usr/local/share:${EROOT}/usr/share"}
	ETCDIR="${EROOT}/etc/eselect/gnome-shell-extensions"
	SCHEMADIR="${EROOT}/usr/share/glib-2.0/schemas"
	OVERRIDE_FILE="eselect-gnome-shell-extensions.gschema.override"
	CONFIG_FILE="config"
	if [[ ! -d "${SCHEMADIR}" ]]; then
		die -q "No ${SCHEMADIR} directory."
	elif [[ ! -d "${ETCDIR}" ]]; then
		die -q "No ${ETCDIR} directory."
	fi

	warnings=()
	errors=()
	available=()
	available_dirs=()
	enabled=()

	if [[ -e "${ETCDIR}/${CONFIG_FILE}" ]]; then
		source "${ETCDIR}/${CONFIG_FILE}" || die -q "Failed to source ${ETCDIR}/${CONFIG_FILE}"
		enabled=( "${enabled_saved[@]}" )
	fi
}

has() {
	# Copied from portage's isolated-functions.sh
	local needle=$1
	shift

	local x
	for x in "$@"; do
		[[ "${x}" = "${needle}" ]] && return 0
	done
	return 1
}

gse_print_warnings() {
	local n

	for (( n = 0; n < ${#warnings[@]}; ++n )); do
		write_warning_msg "${warnings[n]}"
	done

	for (( n = 0; n < ${#errors[@]}-1; ++n )); do
		write_error_msg "${errors[n]}"
	done
	[[ ${#errors[@]} = 0 ]] && return
	die -q "${errors[n]}"
}

gse_die() {
	errors=( "${errors[@]}" "$@" )
	gse_print_warnings
	die # should not happen...
}

gse_read_available() {
	local d

	gse_prepare
	# Do not expand * to '*' if $p is empty
	shopt -s nullglob

	for p in $(echo "${XDG_DATA_DIRS}" | tr -s ':' '\n'); do
		pushd "${p}/gnome-shell/extensions" &> /dev/null || continue
		for d in *; do
			local full_d="${p}/gnome-shell/extensions/${d}"
			# skip invalid extension directories
			if ! [[ -d "${d}" && -f "${d}/metadata.json" && -s "${d}/metadata.json" ]]; then
				warnings=( "${warnings[@]}" "${full_d} is not a valid extension" )
				continue
			fi
			# earlier entries in XDG_DATA_DIRS take precedence
			if has "${d}" "${available[@]}"; then
				warnings=( "${warnings[@]}" "Skipping ${full_d}" )
				continue
			fi
			available_dirs=( "${available_dirs[@]}" "${full_d}" )
			available=( "${available[@]}" "${d}" )
		done
		popd > /dev/null
	done
	# Sort $available
	if [[ -n "${available[@]}" ]]; then
		eval available=( $(printf '%q\n' "${available[@]}" | sort ) )
	fi
}

gse_write_config_file() {
	local f="${ETCDIR}/${CONFIG_FILE}"

	# Sort and uniquefy $enabled
	eval enabled_saved=( $(printf '%q\n' "${enabled[@]}" | sort -u ) )

	if [[ -e "${f}" ]]; then
		[[ -f "${f}" && -w "${f}" ]] || gse_die "${f} is not writable"
	else
		[[ -w "${ETCDIR}" ]] || gse_die "${ETCDIR} is not writable"
	fi

	cat > "${f}" <<EOF || gse_die "Failed to write ${f}"
# Generated and used by eselect gnome-shell-extensions; do not edit manually
$(declare -p enabled_saved)
EOF
}

gse_write_override_file() {
	local f="${ETCDIR}/${OVERRIDE_FILE}"
	local local key value e

	case $(gnome-shell --version) in
	"GNOME Shell 2"* | "GNOME Shell 3.0"* | "GNOME Shell 3.1."[012345678]* )
		# <gnome-shell-3.1.90 uses 'disabled-extensions' key
		key="disabled-extensions"
		for e in "${available[@]}"; do
			has "${e}" "${enabled[@]}" || value+="'${e}', "
		done
		value=`echo "${value}" | sed -e 's:, $::'`
		;;
	* )
		# >=gnome-shell-3.1.90 uses 'enabled-extensions' key
		key="enabled-extensions"
		for e in "${enabled[@]}"; do
			value+="'${e}', "
		done
		value=`echo "${value}" | sed -e 's:, $::'`
		;;
	esac

	if [[ -e "${f}" ]]; then
		[[ -f "${f}" && -w "${f}" ]] || gse_die "${f} not writable"
	else
		[[ -w "${ETCDIR}" ]] || gse_die "${ETCDIR}/ not writable"
	fi

	cat > "${f}" <<EOF || gse_die "Failed to write ${f}"
# Generated and used by eselect gnome-shell-extensions; do not edit manually
[org.gnome.shell]
${key}=[${value}]
EOF
	glib-compile-schemas "${SCHEMADIR}" || gse_die "Failed to compile schemas in ${SCHEMADIR}"
}

gse_get_name() {
	# $1 is an index into available_dirs
	perl -e 'use JSON; undef $/; print decode_json(<>)->{name};' \
		"${available_dirs[${1}]}/metadata.json"
}

gse_get_description() {
	# $1 is an index into available_dirs
	perl -e 'use JSON; undef $/; print decode_json(<>)->{description};' \
		"${available_dirs[${1}]}/metadata.json"
}

### list action

describe_list() {
	echo "List ids of available GNOME Shell extensions"
}

describe_list_options() {
	echo "-v, --verbose : Display extension names and descriptions"
}

do_list() {
	local n

	gse_read_available
	write_list_start "Available extensions ($(highlight '*') means enabled for all users by default):"
	for (( n = 0; n < ${#available[@]}; ++n )); do
		has "${available[n]}" "${enabled[@]}" &&
			available[n]=$(highlight_marker "${available[n]}")
		if [[ $1 = "--verbose" || $1 = "-v" ]]; then
			available[n]+="\n\tfull name   : $(gse_get_name $n)\n\tdescription : $(gse_get_description $n)"
		fi
	done
	write_numbered_list -m "(none found)" "${available[@]}"
	gse_print_warnings
}

### enable action

describe_enable() {
	echo "Enable specified extension(s) for all users by default"
}

describe_enable_parameters() {
	echo "<extension>"
}

describe_enable_options() {
	echo "<extension> : Extension id or number (from 'list' action)"
}

do_enable() {
	local arg ext n

	gse_read_available
	for arg in "$@"; do
		local found=
		for (( n = 0; n < ${#available[@]}; ++n )); do
			ext="${available[n]}"
			if [[ "${arg}" = $((n+1)) || "${arg}" = "${ext}" ]]; then
				has "${ext}" "${enabled[@]}" &&
					warnings=( "${warnings[@]}" "Extension ${arg} is already enabled" )
				# will be uniquefied in gse_write_config_file
				enabled=( "${enabled[@]}" "${ext}" )
				found=yes
				break
			fi
		done
		[[ ${found} = "yes" ]] || errors=( "${errors[@]}" "Failed to find extension ${arg}" )
	done
	gse_write_override_file
	gse_write_config_file
	gse_print_warnings
}

### disable action

describe_disable() {
	echo "Disable specified extension(s) for all users by default"
}

describe_disable_parameters() {
	echo "<extension>"
}

describe_disable_options() {
	echo "<extension> : Extension id or number (from 'list' action)"
}

gse_unenable() {
	# remove $1 from the enabled array
	local found e
	local new_enabled=()

	for e in "${enabled[@]}"; do
		if [[ "$1" = "${e}" ]]; then
			found="yes"
		else
			new_enabled=( "${new_enabled[@]}" "${e}" )
		fi
	done
	enabled=( "${new_enabled[@]}" )
	[[ "${found}" = "yes" ]] && return 0
	return 1
}

do_disable() {
	local arg ext n

	gse_read_available
	for arg in "$@"; do
		local found=
		for (( n = 0; n < ${#available[@]}; ++n )); do
			ext="${available[n]}"
			if [[ "${arg}" = $((n+1)) || "${arg}" = "${ext}" ]]; then
				gse_unenable "${ext}" ||
					warnings=( "${warnings[@]}" "Extension ${arg} is already marked as disabled" )
				found=yes
				break
			fi
		done
		[[ ${found} = "yes" ]] ||
			errors=( "${errors[@]}" "Failed to find extension ${arg}" )
	done
	gse_write_override_file
	gse_write_config_file
	gse_print_warnings
}

### update action

describe_update() {
	echo "Scan for installed extensions, disable ones that haven't been enabled"
	echo "earlier, and update gsettings keys if GNOME Shell has been upgraded"
}

do_update() {
	# Run this after emerging a new extension package
	gse_read_available
	gse_write_override_file
	gse_print_warnings
}
