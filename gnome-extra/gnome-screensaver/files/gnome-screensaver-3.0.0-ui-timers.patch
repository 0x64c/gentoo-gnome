From 669e23233e8364f5ec7478d938df64d820f4b3cc Mon Sep 17 00:00:00 2001
From: Alexandre Rostovtsev <tetromino@gmail.com>
Date: Wed, 20 Jul 2011 14:00:43 -0400
Subject: [PATCH] Add a clock check timer and set watchdog timer in seconds
 (#648145)

This patch adds two changes:
* We need a short timer (e.g. 2 seconds) to check that the panel
  clock has not gotten out of sync with the machine's clock (e.g.
  when the machine resumes from suspend or hibernate, or if the
  machine's clock is reset by ntp). Fixes bug #648145.
* Use 1-second increments for the watchdog timer to save a bit of power.
---
 src/gs-window-x11.c |   60 ++++++++++++++++++++++++++++++++++++++++++++------
 1 files changed, 52 insertions(+), 8 deletions(-)

diff --git a/src/gs-window-x11.c b/src/gs-window-x11.c
index 5120476..7546627 100644
--- a/src/gs-window-x11.c
+++ b/src/gs-window-x11.c
@@ -26,6 +26,7 @@
 #include <errno.h>
 #include <sys/wait.h>
 #include <string.h>
+#include <stdlib.h>
 
 #include <glib/gi18n.h>
 #include <gtk/gtk.h>
@@ -100,6 +101,9 @@ struct GSWindowPrivate
         guint      watchdog_timer_id;
         guint      info_bar_timer_id;
         guint      clock_update_id;
+        guint      clock_check_timer_id;
+
+        GDateTime *local_date_time;
 
         gint       lock_pid;
         gint       lock_watch_id;
@@ -151,6 +155,9 @@ G_DEFINE_TYPE (GSWindow, gs_window, GTK_TYPE_WINDOW)
 
 static void queue_clock_update (GSWindow *window);
 
+static void remove_clock_check_timer (GSWindow *window);
+static void add_clock_check_timer (GSWindow *window);
+
 static void
 set_invisible_cursor (GdkWindow *window,
                       gboolean   invisible)
@@ -481,9 +488,9 @@ static void
 add_watchdog_timer (GSWindow *window,
                     glong     timeout)
 {
-        window->priv->watchdog_timer_id = g_timeout_add (timeout,
-                                                         (GSourceFunc)watchdog_timer,
-                                                         window);
+        window->priv->watchdog_timer_id = g_timeout_add_seconds (timeout,
+                                                                 (GSourceFunc)watchdog_timer,
+                                                                 window);
 }
 
 static void
@@ -671,7 +678,10 @@ gs_window_real_show (GtkWidget *widget)
         window->priv->timer = g_timer_new ();
 
         remove_watchdog_timer (window);
-        add_watchdog_timer (window, 30000);
+        add_watchdog_timer (window, 30);
+
+        remove_clock_check_timer (window);
+        add_clock_check_timer (window);
 
         select_popup_events ();
         window_select_shape_events (window);
@@ -2191,7 +2201,6 @@ update_clock (GSWindow *window)
         const char *clock_format;
         char *text;
         char *markup;
-        GDateTime *dt;
 
         /* clock */
         if (window->priv->clock_format == G_DESKTOP_CLOCK_FORMAT_24H)
@@ -2201,13 +2210,13 @@ update_clock (GSWindow *window)
                 /* Translators, this is the 12h date format used in the panel clock */
                 clock_format = _("%a %l:%M %p");
 
-        dt = g_date_time_new_now_local ();
-        text = g_date_time_format (dt, clock_format);
+        g_date_time_unref (window->priv->local_date_time);
+        window->priv->local_date_time = g_date_time_new_now_local ();
+        text = g_date_time_format (window->priv->local_date_time, clock_format);
         markup = g_strdup_printf ("<b><span foreground=\"#ccc\">%s</span></b>", text);
         gtk_label_set_markup (GTK_LABEL (window->priv->clock), markup);
         g_free (markup);
         g_free (text);
-        g_date_time_unref (dt);
 }
 
 
@@ -2234,6 +2243,38 @@ queue_clock_update (GSWindow *window)
         window->priv->clock_update_id = g_timeout_add (timeouttime, (GSourceFunc)update_clock_timer, window);
 }
 
+/* check that our clock hasn't gotten out of sync with the machine's clock
+   (e.g. when the machine resumes from suspend or hibernate) */
+static gboolean
+clock_check_timer (GSWindow *window)
+{
+        GDateTime* dt;
+
+        dt = g_date_time_new_now_local ();
+        if (labs(g_date_time_difference(dt, window->priv->local_date_time)) >
+            G_USEC_PER_SEC * 60)
+                update_clock_timer (window);
+        g_date_time_unref (dt);
+        return TRUE;
+}
+
+static void
+remove_clock_check_timer (GSWindow *window)
+{
+        if (window->priv->clock_check_timer_id != 0) {
+                g_source_remove (window->priv->clock_check_timer_id);
+                window->priv->clock_check_timer_id = 0;
+        }
+}
+
+static void
+add_clock_check_timer (GSWindow *window)
+{
+        window->priv->clock_check_timer_id = g_timeout_add_seconds (2,
+                                                                    (GSourceFunc)clock_check_timer,
+                                                                    window);
+}
+
 static char *
 get_user_display_name (void)
 {
@@ -2448,6 +2489,9 @@ gs_window_finalize (GObject *object)
 
         remove_watchdog_timer (window);
         remove_popup_dialog_idle (window);
+        remove_clock_check_timer (window);
+
+        g_date_time_unref (window->priv->local_date_time);
 
         if (window->priv->timer) {
                 g_timer_destroy (window->priv->timer);
-- 
1.7.6

