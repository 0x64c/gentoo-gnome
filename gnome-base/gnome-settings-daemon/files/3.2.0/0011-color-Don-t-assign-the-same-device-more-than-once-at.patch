From 9f14a09b2830fa4f7e6a88c656c8b991f93afae2 Mon Sep 17 00:00:00 2001
From: Richard Hughes <richard@hughsie.com>
Date: Fri, 30 Sep 2011 14:05:45 +0100
Subject: [PATCH 4/8] color: Don't assign the same device more than once at
 startup

In the color plugin at startup there's a lot going on async, such as
registering devices and monitoring profiles for changes. As it's all happening
at the "same time", and possibly out-of-order we can't order things linearly in
the startup phase.

This could mean we connect to a device and then straight away get the device
list (which also connects to the device) which means we're doing something twice
we only really need to do once.

Do solve this, use a simple hash table to keep track of what devices are being
assigned at startup. A device gets removed from the cache as soon as it's been
connected to, so we don't end up processing old data.

This speeds up the color plugin start by ~280ms if you have two display devices.
---
 plugins/color/gsd-color-manager.c |   25 +++++++++++++++++++++++++
 1 files changed, 25 insertions(+), 0 deletions(-)

diff --git a/plugins/color/gsd-color-manager.c b/plugins/color/gsd-color-manager.c
index b4b6b3b..4f5f8bc 100644
--- a/plugins/color/gsd-color-manager.c
+++ b/plugins/color/gsd-color-manager.c
@@ -59,6 +59,7 @@ struct GsdColorManagerPrivate
         GHashTable      *edid_cache;
         GdkWindow       *gdk_window;
         GnomeSettingsSessionState session_state;
+        GHashTable      *device_assign_hash;
 };
 
 enum {
@@ -1019,6 +1020,10 @@ gcm_session_device_assign_connect_cb (GObject *object,
         GsdColorManager *manager = GSD_COLOR_MANAGER (user_data);
         GsdColorManagerPrivate *priv = manager->priv;
 
+        /* remove from assign array */
+        g_hash_table_remove (manager->priv->device_assign_hash,
+                             cd_device_get_object_path (device));
+
         /* get properties */
         ret = cd_device_connect_finish (device, res, &error);
         if (!ret) {
@@ -1129,6 +1134,19 @@ out:
 static void
 gcm_session_device_assign (GsdColorManager *manager, CdDevice *device)
 {
+        const gchar *key;
+        gpointer found;
+
+        /* are we already assigning this device */
+        key = cd_device_get_object_path (device);
+        found = g_hash_table_lookup (manager->priv->device_assign_hash, key);
+        if (found != NULL) {
+                g_debug ("assign for %s already in progress", key);
+                return;
+        }
+        g_hash_table_insert (manager->priv->device_assign_hash,
+                             g_strdup (key),
+                             GINT_TO_POINTER (TRUE));
         cd_device_connect (device,
                            NULL,
                            gcm_session_device_assign_connect_cb,
@@ -2043,6 +2061,12 @@ gsd_color_manager_init (GsdColorManager *manager)
                                                   g_free,
                                                   g_object_unref);
 
+        /* we don't want to assign devices multiple times at startup */
+        priv->device_assign_hash = g_hash_table_new_full (g_str_hash,
+                                                          g_str_equal,
+                                                          g_free,
+                                                          NULL);
+
         /* use DMI data for internal panels */
         priv->dmi = gcm_dmi_new ();
 
@@ -2086,6 +2110,7 @@ gsd_color_manager_finalize (GObject *object)
         g_object_unref (manager->priv->dmi);
         g_object_unref (manager->priv->session);
         g_hash_table_destroy (manager->priv->edid_cache);
+        g_hash_table_destroy (manager->priv->device_assign_hash);
         if (manager->priv->x11_screen != NULL)
                 g_object_unref (manager->priv->x11_screen);
 
-- 
1.7.7

